Метод IndexOf
Мы попробовали написать свои первые методы: метод заполнения массива и метод его
печати на экран. Теперь попробуем адаптировать решение предыдущей задачи, в которой
находили нужные элементы и позицию нужного элемента в массиве.
Для этого потребуется описать метод, отличный от void. Он будет возвращать позицию, то
есть index. Назовём этот метод IndexOf, а в качестве аргумента будет приходить массив
collection и какой-то элемент find.
Далее определяем количество элементов через count — collection.Length. Нам потребуются
индексы, чтобы щёлкать массив, пусть это будет переменная index.
Затем возьмём цикл while, который будет проверять index < count. Ведём в фигурные скобки
index++. Напишем следующее: если collection[index] совпал с find, потребуется куда-то сохранить позицию. Чтобы её куда-то сохранить, определим новую переменную position. И
пусть по умолчанию это будет 0. Это не совсем общее решение, но пока подойдёт.
В position положим значение нашего индекса. После того как этот цикл отработает, ожидаем
return position, нашу позицию элемента.
int IndexOf(int[] collection, int find)
{
int index = collection.Length;
int count = 0;
int position = 0;
while (index < count)
{
 If(collection[index] == find)
 {
 position = index;
 }
index++;
}
Return position;
}
Теперь протестируем. Введём Console.WriteLine. Определим переменную pos и положим в
неё результат работы метода IndexOf. В качестве аргумента будет передаваться наш массив.
Например, будем искать число 4.
int pos = IndexOf(array, 4);
Console.WriteLine(pos);
После того как метод отработает, на экране покажем pos. Запустим приложение и посмотрим,
что получится.
Видим перед собой массив, где первая 4 находится на 3 позиции, а вторая — на 4. Получаем
последнее вхождение.
Посмотрим, как изменить код, чтобы получать 1 вхождение. Всё очень просто — через
добавление оператора break. Снова перезапускаем программу и видим, что 4 находится на
нулевой позиции, а других четвёрок нет.
Принудительно добавим пару четвёрок. Пусть, например, на четвёртой позиции будет 4.
После того как мы заполнили всё случайными числами, принудительно добавим пару 4.
Например, на четвёртую позицию и на шестую. Снова запустим dotnet run.
Обратите внимание, что сейчас 3 находится на нулевом индексе, а 4 — на первом индексе.
Встречаются и другие четвёрки, но нам действительно показали первую позицию.
Технически кажется, что мы всё сделали. Но есть проблема: если поискать элемент, которого
точно не существует, например, элемент 444, и запустить этот код, выйдет позиция 0.
Посмотрим, как обходить такие ситуации. Программисты придумали одно изящное решение.
По умолчанию мы указывали позицию 0. Очевидно, что нулевая позиция есть. Если мы ищем
какой-то элемент, то либо он будет равен 0, либо больше 0. Но если не встречается ни одного
элемента, то договоримся, что по умолчанию станет возвращаться значение -1. Это
искусственный приём. То есть, если элемента нет, значит, выйдет -1. Таким образом, если
запустить наш код, обнаружится значение позиции, равное -1. Это значит, что такой элемент
не найден.
